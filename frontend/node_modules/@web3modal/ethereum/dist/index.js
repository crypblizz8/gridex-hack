import{disconnect as h,getAccount as l,watchAccount as w,fetchBalance as d,getNetwork as C,watchNetwork as u,switchNetwork as f,fetchEnsName as g,fetchEnsAvatar as m,connect as s,InjectedConnector as p}from"@wagmi/core";import{WalletConnectConnector as I}from"@wagmi/connectors/walletConnect";import{WalletConnectLegacyConnector as y}from"@wagmi/core/connectors/walletConnectLegacy";import{jsonRpcProvider as W}from"@wagmi/core/providers/jsonRpc";class A{constructor(n,t){this.wagmi={},this.walletConnectUri="",this.walletConnectVersion=1,this.chains=[],this.namespace="eip155",this.disconnect=h,this.getAccount=l,this.watchAccount=w,this.fetchBalance=d,this.getNetwork=C,this.watchNetwork=u,this.switchNetwork=f,this.fetchEnsName=g,this.fetchEnsAvatar=m,this.wagmi=n,this.chains=t;const{isV2:e}=this.getWalletConnectConnectors();this.walletConnectVersion=e?2:1}getDefaultConnectorChainId(n){return n.chains[0].id}getWalletConnectConnectors(){const n=this.wagmi.connectors.find(c=>c.id==="walletConnect"),t=this.wagmi.connectors.find(c=>c.id==="walletConnectLegacy"),e=n??t;if(!e)throw new Error("WalletConnectConnector or WalletConnectLegacyConnector is required");return{isV2:!!n,connector:e}}async connectWalletConnectV1(n,t){return new Promise((e,c)=>{n.once("message",async({type:r})=>{if(r==="connecting"){const o=(await n.getProvider()).connector;this.walletConnectUri=o.uri,t(o.uri),o.on("disconnect",()=>{c(Error())}),o.on("connect",()=>{e()})}})})}async connectWalletConnectV2(n,t){const e=await n.getProvider();let c="";return new Promise(r=>{e.once("display_uri",o=>{this.walletConnectUri=o,c=o,t(o)}),e.once("connect",()=>{c===this.walletConnectUri&&r()})})}getDefaultChain(){const n=this.chains.find(t=>t.id===1);return n??this.chains[0]}getConnectorById(n){const t=this.wagmi.connectors.find(e=>e.id===n);if(!t)throw new Error(`Connector for id ${n} was not found`);return t}getConnectors(){return this.wagmi.connectors.filter(n=>!n.id.includes("walletConnect"))}async connectWalletConnect(n,t){const{connector:e,isV2:c}=this.getWalletConnectConnectors(),r=t??this.getDefaultConnectorChainId(e),o=c?this.connectWalletConnectV2.bind(this):this.connectWalletConnectV1.bind(this),[a]=await Promise.all([s({connector:e,chainId:r}),o(e,n)]);return a}async connectConnector(n,t){const e=this.getConnectorById(n),c=t??this.getDefaultConnectorChainId(e);return await s({connector:e,chainId:c})}}const v="eip155";function P({projectId:i}){return W({rpc:n=>{var t;return[1,3,4,5,10,42,56,69,97,100,137,420,42161,42220,43114,80001,421611,421613,1313161554,11297108109].includes(n.id)?{http:`https://rpc.walletconnect.com/v1/?chainId=${v}:${n.id}&projectId=${i}`}:{http:n.rpcUrls.default.http[0],webSocket:(t=n.rpcUrls.default.webSocket)==null?void 0:t[0]}}})}function j({chains:i,version:n,projectId:t}){const e=n===1,c=[new p({chains:i,options:{shimDisconnect:!0,shimChainChangedDisconnect:!0}})];return e?c.unshift(new y({chains:i,options:{qrcode:!1}})):c.unshift(new I({chains:i,options:{projectId:t,showQrModal:!1}})),c}export{A as EthereumClient,j as w3mConnectors,P as w3mProvider};
//# sourceMappingURL=index.js.map
